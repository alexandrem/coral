syntax = "proto3";
package coral.mesh.v1;

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "coral/agent/v1/agent.proto";

option go_package = "github.com/coral-mesh/coral/proto/discovery/v1;discoverypb";

// StartEbpfCollectorRequest initiates an eBPF collector on an agent.
message StartEbpfCollectorRequest {
  string agent_id = 1;
  string service_name = 2;  // optional; limit to specific workload
  coral.agent.v1.EbpfCollectorKind kind = 3;
  map<string, string> config = 4;         // collector-specific options
  google.protobuf.Duration duration = 5;  // optional; max collection time
}

// StartEbpfCollectorResponse confirms collector start.
message StartEbpfCollectorResponse {
  string collector_id = 1;
  google.protobuf.Timestamp expires_at = 2;
  bool supported = 3;  // false if eBPF not available on this agent
  string error = 4;    // error message if supported=false
}

// StopEbpfCollectorRequest stops a running collector.
message StopEbpfCollectorRequest {
  string collector_id = 1;
}

// StopEbpfCollectorResponse confirms collector stop.
message StopEbpfCollectorResponse {
  bool success = 1;
  string error = 2;
}

// StartUprobeCollectorRequest initiates a uprobe-based function tracer (RFD 059).
message StartUprobeCollectorRequest {
  string agent_id = 1;
  string service_name = 2;
  string function_name = 3;         // e.g., "github.com/myapp/pkg.ValidateCard"
  google.protobuf.Duration duration = 4;  // Max 600s
  UprobeConfig config = 5;
  string sdk_addr = 6;              // SDK debug service address (e.g., "localhost:50051")
}

// UprobeConfig specifies what data to capture from function calls.
message UprobeConfig {
  bool capture_args = 1;            // Capture function arguments
  bool capture_return = 2;          // Capture return values
  uint32 sample_rate = 3;           // Sample every Nth call (0 = all)
  uint32 max_events = 4;            // Max events to collect (safety limit)
}

// StartUprobeCollectorResponse confirms uprobe attachment.
message StartUprobeCollectorResponse {
  string collector_id = 1;
  google.protobuf.Timestamp expires_at = 2;
  bool supported = 3;  // false if uprobes not available
  string error = 4;    // error message if supported=false
}

// StopUprobeCollectorRequest stops a running uprobe collector.
message StopUprobeCollectorRequest {
  string collector_id = 1;
}

// StopUprobeCollectorResponse confirms uprobe stop.
message StopUprobeCollectorResponse {
  bool success = 1;
  string error = 2;
}

// QueryUprobeEventsRequest retrieves events from a uprobe collector.
message QueryUprobeEventsRequest {
  string collector_id = 1;
  google.protobuf.Timestamp start_time = 2;
  google.protobuf.Timestamp end_time = 3;
  int32 max_events = 4;             // Pagination
}

// QueryUprobeEventsResponse returns collected events.
message QueryUprobeEventsResponse {
  repeated EbpfEvent events = 1;
  bool has_more = 2;                // Pagination indicator
}


// EbpfEventStreamRequest requests streaming of eBPF events.
message EbpfEventStreamRequest {
  string collector_id = 1;
}

// SyscallStats contains aggregated syscall statistics.
message SyscallStats {
  string syscall_name = 1;
  uint64 call_count = 2;
  uint64 error_count = 3;
  uint64 total_duration_us = 4;  // total time in microseconds
  map<string, string> labels = 5;
}

// HttpLatencyHistogram contains HTTP request latency distribution.
message HttpLatencyHistogram {
  repeated double buckets = 1;      // bucket boundaries in milliseconds
  repeated uint64 counts = 2;       // event count per bucket
  string unit = 3;                  // "milliseconds"
  map<string, string> labels = 4;   // method, status, pod, etc.
}

// CpuProfileSample contains a CPU profile stack sample.
message CpuProfileSample {
  repeated string stack = 1;        // symbolized stack frames (top-to-bottom)
  uint64 count = 2;                 // sample count for this stack
  map<string, string> labels = 3;
}

// Beyla-specific capabilities reported by agent (RFD 032).
message BeylaCapabilities {
  bool enabled = 1;
  string version = 2;  // Beyla library version
  repeated string supported_protocols = 3;  // ["http", "grpc", "kafka", ...]
  repeated string supported_runtimes = 4;   // ["go", "java", "python", ...]
  bool tracing_enabled = 5;
}

// Beyla HTTP metrics (aggregated by agent before sending).
message BeylaHttpMetrics {
  google.protobuf.Timestamp timestamp = 1;
  string service_name = 2;
  string http_route = 3;          // e.g., "/api/v1/users/:id"
  string http_method = 4;         // GET, POST, etc.
  uint32 http_status_code = 5;

  // Latency histogram buckets (milliseconds).
  repeated double latency_buckets = 6;  // [10, 25, 50, 100, 250, 500, 1000, 2500, 5000]
  repeated uint64 latency_counts = 7;   // Counts per bucket

  uint64 request_count = 8;             // Total requests in time window
  map<string, string> attributes = 9;   // pod, namespace, cluster, etc.
}

// Beyla gRPC metrics.
message BeylaGrpcMetrics {
  google.protobuf.Timestamp timestamp = 1;
  string service_name = 2;
  string grpc_method = 3;         // e.g., "/payments.PaymentService/Charge"
  uint32 grpc_status_code = 4;    // 0 = OK, 1 = CANCELLED, etc.

  repeated double latency_buckets = 5;
  repeated uint64 latency_counts = 6;

  uint64 request_count = 7;
  map<string, string> attributes = 8;
}

// Beyla SQL metrics.
message BeylaSqlMetrics {
  google.protobuf.Timestamp timestamp = 1;
  string service_name = 2;
  string sql_operation = 3;       // SELECT, INSERT, UPDATE, DELETE
  string table_name = 4;          // Extracted from query (if possible)

  repeated double latency_buckets = 5;
  repeated uint64 latency_counts = 6;

  uint64 query_count = 7;
  map<string, string> attributes = 8;
}

// Distributed trace span (OpenTelemetry-compatible).
message BeylaTraceSpan {
  string trace_id = 1;            // 32-char hex string
  string span_id = 2;             // 16-char hex string
  string parent_span_id = 3;      // Empty if root span

  string service_name = 4;
  string span_name = 5;           // e.g., "GET /api/v1/users/:id"
  string span_kind = 6;           // "server", "client", "producer", "consumer"

  google.protobuf.Timestamp start_time = 7;
  google.protobuf.Duration duration = 8;

  uint32 status_code = 9;         // HTTP/gRPC status
  map<string, string> attributes = 10;
}

// FunctionArgument represents a captured function argument (RFD 059).
message FunctionArgument {
  string name = 1;                  // Argument name from DWARF
  string type = 2;                  // Go type
  string value = 3;                 // String representation (limited depth)
}

// FunctionReturnValue represents a captured return value (RFD 059).
message FunctionReturnValue {
  string type = 1;
  string value = 2;
  bool is_error = 3;                // For Go error returns
  string error_message = 4;
}

// UprobeEvent represents a single function entry/return event (RFD 059).
message UprobeEvent {
  google.protobuf.Timestamp timestamp = 1;
  string collector_id = 2;
  string agent_id = 3;
  string service_name = 4;
  string function_name = 5;

  string event_type = 6;            // "entry" or "return"
  uint64 duration_ns = 7;           // Only for "return" events

  int32 pid = 8;
  int32 tid = 9;

  // Argument/return value capture (optional, based on config).
  repeated FunctionArgument args = 10;
  FunctionReturnValue return_value = 11;

  map<string, string> labels = 12;
}

// EbpfEvent represents a single eBPF event or aggregated summary.
message EbpfEvent {
  google.protobuf.Timestamp timestamp = 1;
  string collector_id = 2;
  string agent_id = 3;
  string service_name = 4;

  oneof payload {
    SyscallStats syscall_stats = 10;
    HttpLatencyHistogram http_latency = 11;
    CpuProfileSample cpu_profile = 12;

    // Beyla collectors (RFD 032)
    BeylaHttpMetrics beyla_http = 20;
    BeylaGrpcMetrics beyla_grpc = 21;
    BeylaSqlMetrics beyla_sql = 22;
    BeylaTraceSpan beyla_trace = 23;

    // Uprobe collectors (RFD 059)
    UprobeEvent uprobe_event = 30;
  }
}

// EbpfService handles eBPF collector management.
service EbpfService {
  // Start an eBPF collector on an agent.
  rpc StartCollector(StartEbpfCollectorRequest) returns (StartEbpfCollectorResponse);

  // Stop a running eBPF collector.
  rpc StopCollector(StopEbpfCollectorRequest) returns (StopEbpfCollectorResponse);

  // Stream eBPF events from a collector.
  rpc StreamEvents(EbpfEventStreamRequest) returns (stream EbpfEvent);
}

// DebugService handles uprobe-based debugging operations (RFD 059).
service DebugService {
  // Start a uprobe collector on an agent.
  rpc StartUprobeCollector(StartUprobeCollectorRequest) returns (StartUprobeCollectorResponse);

  // Stop a running uprobe collector.
  rpc StopUprobeCollector(StopUprobeCollectorRequest) returns (StopUprobeCollectorResponse);

  // Query events from a uprobe collector.
  rpc QueryUprobeEvents(QueryUprobeEventsRequest) returns (QueryUprobeEventsResponse);
}
