syntax = "proto3";

package coral.agent.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/coral-io/coral/coral/agent/v1;agentv1";

// Agent service for runtime context and operations.
service AgentService {
  // Get runtime context information.
  rpc GetRuntimeContext(GetRuntimeContextRequest) returns (RuntimeContextResponse);

  // Dynamically connect to a service for monitoring.
  rpc ConnectService(ConnectServiceRequest) returns (ConnectServiceResponse);

  // Disconnect from a service.
  rpc DisconnectService(DisconnectServiceRequest) returns (DisconnectServiceResponse);

  // List currently monitored services.
  rpc ListServices(ListServicesRequest) returns (ListServicesResponse);
}

message GetRuntimeContextRequest {
  // Empty - returns current runtime context.
}

message RuntimeContextResponse {
  // Platform information.
  PlatformInfo platform = 1;

  // Runtime type.
  RuntimeContext runtime_type = 2;

  // Sidecar mode (if K8s).
  SidecarMode sidecar_mode = 3;

  // CRI socket info.
  CRISocketInfo cri_socket = 4;

  // Capabilities.
  Capabilities capabilities = 5;

  // Visibility scope.
  VisibilityScope visibility = 6;

  // Detection metadata.
  google.protobuf.Timestamp detected_at = 7;

  // Agent version.
  string version = 8;

  // eBPF capabilities (RFD 013).
  EbpfCapabilities ebpf_capabilities = 9;
}

message PlatformInfo {
  // Operating system: "linux", "darwin", "windows".
  string os = 1;

  // Architecture: "amd64", "arm64".
  string arch = 2;

  // OS version: "Ubuntu 22.04", "macOS 14.2".
  string os_version = 3;

  // Kernel version: "6.5.0-35-generic", "Darwin 23.3.0".
  string kernel = 4;
}

message CRISocketInfo {
  // Socket path: "/var/run/containerd/containerd.sock".
  string path = 1;

  // Runtime type: "containerd", "crio", "docker".
  string type = 2;

  // Runtime version: "1.7.0".
  string version = 3;
}

message VisibilityScope {
  // Can see all host PIDs.
  bool all_pids = 1;

  // Can see all containers.
  bool all_containers = 2;

  // Limited to pod scope.
  bool pod_scope = 3;

  // Explicit target container IDs.
  repeated string container_ids = 4;

  // Namespace type: "host", "container", "pod", "node".
  string namespace = 5;
}

message Capabilities {
  // Can run new containers/processes.
  bool can_run = 1;

  // Can exec into existing containers/processes.
  bool can_exec = 2;

  // Can open interactive shell.
  bool can_shell = 3;

  // Can monitor/observe (always true).
  bool can_connect = 4;
}

enum RuntimeContext {
  // Unknown runtime.
  RUNTIME_CONTEXT_UNKNOWN = 0;

  // Native process on host.
  RUNTIME_CONTEXT_NATIVE = 1;

  // Docker container.
  RUNTIME_CONTEXT_DOCKER = 2;

  // Kubernetes sidecar.
  RUNTIME_CONTEXT_K8S_SIDECAR = 3;

  // Kubernetes DaemonSet.
  RUNTIME_CONTEXT_K8S_DAEMONSET = 4;
}

enum SidecarMode {
  // Unknown sidecar mode.
  SIDECAR_MODE_UNKNOWN = 0;

  // CRI socket available.
  SIDECAR_MODE_CRI = 1;

  // Shared process namespace.
  SIDECAR_MODE_SHARED_NS = 2;

  // Passive mode (limited capabilities).
  SIDECAR_MODE_PASSIVE = 3;
}

// ConnectService RPC messages.
message ConnectServiceRequest {
  // Service name.
  string component_name = 1;

  // Service port number.
  int32 port = 2;

  // Optional health check endpoint path.
  string health_endpoint = 3;

  // Optional service type hint.
  string service_type = 4;

  // Additional metadata.
  map<string, string> labels = 5;
}

message ConnectServiceResponse {
  // Success indicator.
  bool success = 1;

  // Error message if not successful.
  string error = 2;

  // Service name that was connected.
  string service_name = 3;
}

// DisconnectService RPC messages.
message DisconnectServiceRequest {
  // Service name to disconnect.
  string service_name = 1;
}

message DisconnectServiceResponse {
  // Success indicator.
  bool success = 1;

  // Error message if not successful.
  string error = 2;
}

// ListServices RPC messages.
message ListServicesRequest {
  // Empty - returns all monitored services.
}

message ListServicesResponse {
  // Currently monitored services.
  repeated ServiceStatus services = 1;
}

message ServiceStatus {
  // Service name.
  string component_name = 1;

  // Service port number.
  int32 port = 2;

  // Optional health check endpoint path.
  string health_endpoint = 3;

  // Optional service type hint.
  string service_type = 4;

  // Additional metadata.
  map<string, string> labels = 5;

  // Current status.
  string status = 6;  // "healthy", "unhealthy", "unknown"

  // Last check timestamp.
  google.protobuf.Timestamp last_check = 7;

  // Error message if unhealthy.
  string error = 8;
}

// EbpfCollectorKind defines the type of eBPF collector (RFD 013).
enum EbpfCollectorKind {
  EBPF_COLLECTOR_KIND_UNSPECIFIED = 0;
  EBPF_COLLECTOR_KIND_SYSCALL_STATS = 1;
  EBPF_COLLECTOR_KIND_HTTP_LATENCY = 2;
  EBPF_COLLECTOR_KIND_CPU_PROFILE = 3;
  EBPF_COLLECTOR_KIND_TCP_METRICS = 4;
}

// EbpfCapabilities describes what eBPF features are supported on an agent (RFD 013).
message EbpfCapabilities {
  bool supported = 1;               // overall eBPF support
  string kernel_version = 2;        // e.g., "5.15.0"
  bool btf_available = 3;           // BTF/CO-RE support
  bool cap_bpf = 4;                 // CAP_BPF capability
  repeated EbpfCollectorKind available_collectors = 5;
}

