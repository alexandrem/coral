syntax = "proto3";

package coral.agent.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/coral-mesh/coral/coral/agent/v1;agentv1";

// Agent service for runtime context and operations.
service AgentService {
  // Get runtime context information.
  rpc GetRuntimeContext(GetRuntimeContextRequest) returns (RuntimeContextResponse);

  // Dynamically connect to a service for monitoring.
  rpc ConnectService(ConnectServiceRequest) returns (ConnectServiceResponse);

  // Disconnect from a service.
  rpc DisconnectService(DisconnectServiceRequest) returns (DisconnectServiceResponse);

  // List currently monitored services.
  rpc ListServices(ListServicesRequest) returns (ListServicesResponse);

  // Query telemetry data from agent local storage (RFD 025 - pull-based).
  rpc QueryTelemetry(QueryTelemetryRequest) returns (QueryTelemetryResponse);

  // Query eBPF metrics from agent local storage (RFD 032 Phase 4 - pull-based).
  rpc QueryEbpfMetrics(QueryEbpfMetricsRequest) returns (QueryEbpfMetricsResponse);

  // Shell: Interactive shell session in agent environment (RFD 026).
  rpc Shell(stream ShellRequest) returns (stream ShellResponse);

  // ShellExec: One-off command execution in agent environment (RFD 045).
  rpc ShellExec(ShellExecRequest) returns (ShellExecResponse);

  // ContainerExec: Execute command in container namespace (RFD 056).
  rpc ContainerExec(ContainerExecRequest) returns (ContainerExecResponse);

  // Resize shell terminal (RFD 026).
  rpc ResizeShellTerminal(ResizeShellTerminalRequest) returns (ResizeShellTerminalResponse);

  // Send signal to shell session (RFD 026).
  rpc SendShellSignal(SendShellSignalRequest) returns (SendShellSignalResponse);

  // Kill shell session (RFD 026).
  rpc KillShellSession(KillShellSessionRequest) returns (KillShellSessionResponse);

  // StreamDebugEvents streams debug events from agent to colony (RFD 061).
  rpc StreamDebugEvents(stream DebugCommand) returns (stream DebugEvent);
}

message GetRuntimeContextRequest {
  // Empty - returns current runtime context.
}

message RuntimeContextResponse {
  // Platform information.
  PlatformInfo platform = 1;

  // Runtime type.
  RuntimeContext runtime_type = 2;

  // Sidecar mode (if K8s).
  SidecarMode sidecar_mode = 3;

  // CRI socket info.
  CRISocketInfo cri_socket = 4;

  // Capabilities.
  Capabilities capabilities = 5;

  // Visibility scope.
  VisibilityScope visibility = 6;

  // Detection metadata.
  google.protobuf.Timestamp detected_at = 7;

  // Agent version.
  string version = 8;

  // eBPF capabilities (RFD 013).
  EbpfCapabilities ebpf_capabilities = 9;

  // Agent ID.
  string agent_id = 10;
}

message PlatformInfo {
  // Operating system: "linux", "darwin", "windows".
  string os = 1;

  // Architecture: "amd64", "arm64".
  string arch = 2;

  // OS version: "Ubuntu 22.04", "macOS 14.2".
  string os_version = 3;

  // Kernel version: "6.5.0-35-generic", "Darwin 23.3.0".
  string kernel = 4;
}

message CRISocketInfo {
  // Socket path: "/var/run/containerd/containerd.sock".
  string path = 1;

  // Runtime type: "containerd", "crio", "docker".
  string type = 2;

  // Runtime version: "1.7.0".
  string version = 3;
}

message VisibilityScope {
  // Can see all host PIDs.
  bool all_pids = 1;

  // Can see all containers.
  bool all_containers = 2;

  // Limited to pod scope.
  bool pod_scope = 3;

  // Explicit target container IDs.
  repeated string container_ids = 4;

  // Namespace type: "host", "container", "pod", "node".
  string namespace = 5;
}

message Capabilities {
  // Can run new containers/processes.
  bool can_run = 1;

  // Can exec into existing containers/processes.
  bool can_exec = 2;

  // Can open interactive shell.
  bool can_shell = 3;

  // Can monitor/observe (always true).
  bool can_connect = 4;

  // Detailed exec mode information (RFD 057).
  ExecCapabilities exec_capabilities = 5;

  // Linux capabilities granted to agent (RFD 057).
  LinuxCapabilities linux_capabilities = 6;
}

// LinuxCapabilities represents Linux kernel capabilities granted to the agent (RFD 057).
// Mapped from /proc/self/status Cap* fields.
message LinuxCapabilities {
  // WireGuard mesh networking (required for all deployments).
  bool cap_net_admin = 1;

  // Container namespace execution via nsenter (coral exec nsenter mode).
  bool cap_sys_admin = 2;

  // Process inspection via /proc (required for coral exec PID detection).
  bool cap_sys_ptrace = 3;

  // eBPF memory locking (required for eBPF collectors).
  bool cap_sys_resource = 4;

  // Modern eBPF without CAP_SYS_ADMIN (kernel 5.8+).
  bool cap_bpf = 5;

  // Performance monitoring eBPF (kernel 5.8+).
  bool cap_perfmon = 6;

  // Additional capabilities for future use.
  bool cap_dac_override = 7;
  bool cap_setuid = 8;
  bool cap_setgid = 9;
}

// ExecCapabilities describes available container execution modes (RFD 057).
message ExecCapabilities {
  // Exec mode available to the agent.
  ExecMode mode = 1;

  // Can access container mount namespace (nsenter -m).
  bool mount_namespace_access = 2;

  // Can access container PID namespace (nsenter -p).
  bool pid_namespace_access = 3;

  // Requirements for nsenter mode.
  bool has_sys_admin = 4;   // CAP_SYS_ADMIN available
  bool has_sys_ptrace = 5;  // CAP_SYS_PTRACE available
  bool has_shared_pid_ns = 6; // Shared PID namespace or hostPID

  // Fallback to CRI if nsenter not available.
  bool cri_socket_available = 7;
}

// ExecMode defines the container execution mode (RFD 057).
enum ExecMode {
  EXEC_MODE_UNKNOWN = 0;  // Not yet detected
  EXEC_MODE_NONE = 1;     // No exec support
  EXEC_MODE_CRI = 2;      // CRI-based exec (limited, no mount namespace)
  EXEC_MODE_NSENTER = 3;  // nsenter-based exec (full container filesystem access)
}

enum RuntimeContext {
  // Unknown runtime.
  RUNTIME_CONTEXT_UNKNOWN = 0;

  // Native process on host.
  RUNTIME_CONTEXT_NATIVE = 1;

  // Docker container.
  RUNTIME_CONTEXT_DOCKER = 2;

  // Kubernetes sidecar.
  RUNTIME_CONTEXT_K8S_SIDECAR = 3;

  // Kubernetes DaemonSet.
  RUNTIME_CONTEXT_K8S_DAEMONSET = 4;
}

enum SidecarMode {
  // Unknown sidecar mode.
  SIDECAR_MODE_UNKNOWN = 0;

  // CRI socket available.
  SIDECAR_MODE_CRI = 1;

  // Shared process namespace.
  SIDECAR_MODE_SHARED_NS = 2;

  // Passive mode (limited capabilities).
  SIDECAR_MODE_PASSIVE = 3;
}

// ConnectService RPC messages.
message ConnectServiceRequest {
  // Service name.
  string name = 1;

  // Service port number.
  int32 port = 2;

  // Optional health check endpoint path.
  string health_endpoint = 3;

  // Optional service type hint.
  string service_type = 4;

  // Additional metadata.
  map<string, string> labels = 5;

  // SDK capabilities (RFD 060).
  ServiceSdkCapabilities sdk_capabilities = 6;
}

// ServiceSdkCapabilities describes the SDK integration status (RFD 060).
message ServiceSdkCapabilities {
  string service_name = 1;           // Service identifier
  string process_id = 2;             // PID of service process

  // SDK integration status
  bool sdk_enabled = 3;              // SDK detected and reachable
  string sdk_version = 4;            // SDK version (e.g., "v1.0.0")
  string sdk_addr = 5;               // SDK gRPC address (reachable by Agent)

  // Debug symbol availability
  bool has_dwarf_symbols = 6;        // DWARF debug info present
  uint32 function_count = 7;         // Number of discoverable functions

  // Binary information
  string binary_path = 10;           // Path to executable
  string binary_hash = 11;           // Hash for cache invalidation
}

message ConnectServiceResponse {
  // Success indicator.
  bool success = 1;

  // Error message if not successful.
  string error = 2;

  // Service name that was connected.
  string service_name = 3;
}

// DisconnectService RPC messages.
message DisconnectServiceRequest {
  // Service name to disconnect.
  string service_name = 1;
}

message DisconnectServiceResponse {
  // Success indicator.
  bool success = 1;

  // Error message if not successful.
  string error = 2;
}

// ListServices RPC messages.
message ListServicesRequest {
  // Empty - returns all monitored services.
}

message ListServicesResponse {
  // Currently monitored services.
  repeated ServiceStatus services = 1;
}

message ServiceStatus {
  // Service name.
  string name = 1;

  // Service port number.
  int32 port = 2;

  // Optional health check endpoint path.
  string health_endpoint = 3;

  // Optional service type hint.
  string service_type = 4;

  // Additional metadata.
  map<string, string> labels = 5;

  // Current status.
  string status = 6;  // "healthy", "unhealthy", "unknown"

  // Last check timestamp.
  google.protobuf.Timestamp last_check = 7;

  // Error message if unhealthy.
  string error = 8;

  // Process information (RFD 064).
  int32 process_id = 9;        // Process ID running the service (0 if unknown)
  string binary_path = 10;     // Path to service executable (empty if unknown)
  string binary_hash = 11;     // Hash of binary for cache invalidation (optional)
}

// EbpfCollectorKind defines the type of eBPF collector (RFD 013).
enum EbpfCollectorKind {
  EBPF_COLLECTOR_KIND_UNSPECIFIED = 0;
  EBPF_COLLECTOR_KIND_SYSCALL_STATS = 1;
  EBPF_COLLECTOR_KIND_HTTP_LATENCY = 2;
  EBPF_COLLECTOR_KIND_CPU_PROFILE = 3;
  EBPF_COLLECTOR_KIND_TCP_METRICS = 4;
  EBPF_COLLECTOR_KIND_UPROBE = 5;  // RFD 059 - Application-level function debugging
}

// EbpfCapabilities describes what eBPF features are supported on an agent (RFD 013).
message EbpfCapabilities {
  bool supported = 1;               // overall eBPF support
  string kernel_version = 2;        // e.g., "5.15.0"
  bool btf_available = 3;           // BTF/CO-RE support
  bool cap_bpf = 4;                 // CAP_BPF capability
  repeated EbpfCollectorKind available_collectors = 5;
  EbpfObservabilityCapabilities ebpf_observability = 6;      // eBPF observability capabilities (RFD 032)
}

// EbpfObservabilityCapabilities describes eBPF observability features (RFD 032).
message EbpfObservabilityCapabilities {
  bool enabled = 1;
  string version = 2;  // Beyla library version
  repeated string supported_protocols = 3;  // ["http", "grpc", "kafka", ...]
  repeated string supported_runtimes = 4;   // ["go", "java", "python", ...]
  bool tracing_enabled = 5;
}

// QueryTelemetry RPC messages (RFD 025 - pull-based telemetry).

// TelemetrySpan represents a filtered OpenTelemetry span stored locally on agents.
message TelemetrySpan {
  // Span timestamp (Unix milliseconds).
  int64 timestamp = 1;

  // OpenTelemetry trace ID.
  string trace_id = 2;

  // OpenTelemetry span ID.
  string span_id = 3;

  // Service name from span attributes.
  string service_name = 4;

  // Span kind (CLIENT, SERVER, INTERNAL, PRODUCER, CONSUMER).
  string span_kind = 5;

  // Span duration in milliseconds.
  double duration_ms = 6;

  // Whether this span represents an error.
  bool is_error = 7;

  // HTTP status code (if applicable).
  int32 http_status = 8;

  // HTTP method (if applicable).
  string http_method = 9;

  // HTTP route (if applicable).
  string http_route = 10;

  // Additional span attributes (key-value pairs).
  map<string, string> attributes = 11;
}

// QueryTelemetryRequest is sent from colony to agent to query recent telemetry.
message QueryTelemetryRequest {
  // Start time for query range (Unix seconds).
  int64 start_time = 1;

  // End time for query range (Unix seconds).
  int64 end_time = 2;

  // Filter by service names (empty = all services).
  repeated string service_names = 3;
}

// QueryTelemetryResponse contains filtered spans from agent's local storage.
message QueryTelemetryResponse {
  // Filtered spans matching the query.
  repeated TelemetrySpan spans = 1;

  // Total number of spans returned.
  int32 total_spans = 2;
}

// QueryEbpfMetrics RPC messages (RFD 032 Phase 4 - pull-based).

// QueryEbpfMetricsRequest is sent from colony to agent to query eBPF metrics.
message QueryEbpfMetricsRequest {
  // Start time for query range (Unix seconds).
  int64 start_time = 1;

  // End time for query range (Unix seconds).
  int64 end_time = 2;

  // Filter by service names (empty = all services).
  repeated string service_names = 3;

  // Metric types to query (empty = all types).
  repeated EbpfMetricType metric_types = 4;

  // Filter by specific trace ID (RFD 036).
  string trace_id = 5;

  // Limit number of traces returned (default: 100, max: 1000) (RFD 036).
  int32 max_traces = 6;

  // Include traces in response (default: false for backward compatibility) (RFD 036).
  bool include_traces = 7;
}

// EbpfMetricType specifies which eBPF metrics to query.
enum EbpfMetricType {
  EBPF_METRIC_TYPE_UNSPECIFIED = 0;
  EBPF_METRIC_TYPE_HTTP = 1;
  EBPF_METRIC_TYPE_GRPC = 2;
  EBPF_METRIC_TYPE_SQL = 3;
}

// QueryEbpfMetricsResponse contains eBPF metrics from agent's local storage.
message QueryEbpfMetricsResponse {
  // HTTP metrics.
  repeated EbpfHttpMetric http_metrics = 1;

  // gRPC metrics.
  repeated EbpfGrpcMetric grpc_metrics = 2;

  // SQL metrics.
  repeated EbpfSqlMetric sql_metrics = 3;

  // Total metrics returned.
  int32 total_metrics = 4;

  // Trace spans (RFD 036).
  repeated EbpfTraceSpan trace_spans = 5;

  // Total traces returned (RFD 036).
  int32 total_traces = 6;
}

// EbpfHttpMetric represents aggregated HTTP RED metrics.
message EbpfHttpMetric {
  // Timestamp (Unix milliseconds).
  int64 timestamp = 1;

  // Service name.
  string service_name = 2;

  // HTTP method (GET, POST, etc.).
  string http_method = 3;

  // HTTP route (/api/v1/users/:id).
  string http_route = 4;

  // HTTP status code (200, 404, 500, etc.).
  uint32 http_status_code = 5;

  // Latency histogram buckets (milliseconds).
  repeated double latency_buckets = 6;

  // Counts per bucket.
  repeated uint64 latency_counts = 7;

  // Request count.
  uint64 request_count = 8;

  // Additional attributes.
  map<string, string> attributes = 9;
}

// EbpfGrpcMetric represents aggregated gRPC RED metrics.
message EbpfGrpcMetric {
  // Timestamp (Unix milliseconds).
  int64 timestamp = 1;

  // Service name.
  string service_name = 2;

  // gRPC method (/payments.PaymentService/Charge).
  string grpc_method = 3;

  // gRPC status code (0 = OK, 1 = CANCELLED, etc.).
  uint32 grpc_status_code = 4;

  // Latency histogram buckets (milliseconds).
  repeated double latency_buckets = 5;

  // Counts per bucket.
  repeated uint64 latency_counts = 6;

  // Request count.
  uint64 request_count = 7;

  // Additional attributes.
  map<string, string> attributes = 8;
}

// EbpfSqlMetric represents aggregated SQL query metrics.
message EbpfSqlMetric {
  // Timestamp (Unix milliseconds).
  int64 timestamp = 1;

  // Service name.
  string service_name = 2;

  // SQL operation (SELECT, INSERT, UPDATE, DELETE).
  string sql_operation = 3;

  // Table name (extracted from query if possible).
  string table_name = 4;

  // Latency histogram buckets (milliseconds).
  repeated double latency_buckets = 5;

  // Counts per bucket.
  repeated uint64 latency_counts = 6;

  // Query count.
  uint64 query_count = 7;

  // Additional attributes.
  map<string, string> attributes = 8;
}

// EbpfTraceSpan represents a distributed trace span (RFD 036).
message EbpfTraceSpan {
  // Trace ID (32-char hex string).
  string trace_id = 1;

  // Span ID (16-char hex string).
  string span_id = 2;

  // Parent span ID (empty if root span).
  string parent_span_id = 3;

  // Service name.
  string service_name = 4;

  // Span name (e.g., "GET /api/v1/users/:id").
  string span_name = 5;

  // Span kind ("server", "client", "producer", "consumer").
  string span_kind = 6;

  // Start timestamp (Unix milliseconds).
  int64 start_time = 7;

  // Duration (microseconds).
  int64 duration_us = 8;

  // HTTP/gRPC status code.
  uint32 status_code = 9;

  // Additional attributes.
  map<string, string> attributes = 10;
}

// Shell RPC messages (RFD 026).

message ShellRequest {
  oneof payload {
    ShellStart start = 1;     // First message from client
    bytes stdin = 2;          // Stdin data from client
    ShellResize resize = 3;   // Terminal resize event
    ShellSignal signal = 4;   // Signal to send to shell
  }
}

message ShellStart {
  string shell = 1;             // /bin/bash, /bin/sh (default: /bin/bash)
  map<string, string> env = 2;  // Additional environment variables
  TerminalSize size = 3;        // Initial terminal size
  string user_id = 4;           // User making request (for audit)
  string approval_id = 5;       // Approval request ID (if required)
}

message ShellResponse {
  oneof payload {
    bytes output = 1;         // Stdout/stderr data from shell
    ShellExit exit = 2;       // Final message with exit code
  }
}

message ShellExit {
  int32 exit_code = 1;
  string session_id = 2;  // Session ID for audit reference
}

message TerminalSize {
  uint32 rows = 1;
  uint32 cols = 2;
}

message ShellResize {
  uint32 rows = 1;
  uint32 cols = 2;
}

message ShellSignal {
  string signal = 1;  // SIGINT, SIGTERM, SIGTSTP, etc.
}

message ResizeShellTerminalRequest {
  string session_id = 1;
  uint32 rows = 2;
  uint32 cols = 3;
}

message ResizeShellTerminalResponse {
  bool success = 1;
  string error = 2;
}

message SendShellSignalRequest {
  string session_id = 1;
  string signal = 2;
}

message SendShellSignalResponse {
  bool success = 1;
  string error = 2;
}

message KillShellSessionRequest {
  string session_id = 1;
}

message KillShellSessionResponse {
  bool success = 1;
  string error = 2;
}

// ShellExec RPC messages (RFD 045 - one-off command execution).

message ShellExecRequest {
  // Command as array (no shell interpretation - prevents injection).
  // Example: ["ps", "aux"] or ["tcpdump", "-i", "any", "port", "80"]
  repeated string command = 1;

  // User making request (for audit).
  string user_id = 2;

  // Timeout in seconds (default: 30, max: 300).
  uint32 timeout_seconds = 3;

  // Working directory (default: agent's working dir).
  string working_dir = 4;

  // Additional environment variables.
  map<string, string> env = 5;
}

message ShellExecResponse {
  // Standard output from command.
  bytes stdout = 1;

  // Standard error from command.
  bytes stderr = 2;

  // Exit code from command.
  int32 exit_code = 3;

  // Session ID for audit reference.
  string session_id = 4;

  // Execution duration in milliseconds.
  uint32 duration_ms = 5;

  // Error message if execution failed (timeout, command not found, etc.).
  string error = 6;
}

// ContainerExec RPC messages (RFD 056 - container namespace execution).

message ContainerExecRequest {
  // Container name (optional in sidecar mode - defaults to main container).
  string container_name = 1;

  // Command as array (no shell interpretation).
  // Example: ["cat", "/app/config.yaml"] or ["ls", "-la", "/etc/nginx"]
  repeated string command = 2;

  // User making request (for audit).
  string user_id = 3;

  // Timeout in seconds (default: 30, max: 300).
  uint32 timeout_seconds = 4;

  // Working directory (optional, uses container's default).
  string working_dir = 5;

  // Additional environment variables.
  map<string, string> env = 6;

  // Namespaces to enter (default: ["mnt"] for sidecar mode).
  // Options: "mnt", "pid", "net", "ipc", "uts", "cgroup"
  repeated string namespaces = 7;
}

message ContainerExecResponse {
  // Standard output from command.
  bytes stdout = 1;

  // Standard error from command.
  bytes stderr = 2;

  // Exit code from command.
  int32 exit_code = 3;

  // Session ID for audit reference.
  string session_id = 4;

  // Execution duration in milliseconds.
  uint32 duration_ms = 5;

  // Error message if execution failed.
  string error = 6;

  // Container PID used for nsenter (for debugging).
  int32 container_pid = 7;

  // Namespaces that were entered.
  repeated string namespaces_entered = 8;
}



// Debug RPC messages (RFD 061).

message DebugEvent {
  string session_id = 1;
  int64 timestamp = 2;
  int32 pid = 3;
  int32 tid = 4;
  int64 duration_ns = 5;
  // Additional context if needed
}

message DebugCommand {
  string session_id = 1;
  string command = 2; // "detach"
}
