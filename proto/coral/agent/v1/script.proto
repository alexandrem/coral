syntax = "proto3";

package coral.agent.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/coral-mesh/coral/coral/agent/v1;agentv1";

// Script metadata and deployment information (RFD 076).
message Script {
  // Unique script identifier (UUID).
  string id = 1;

  // Human-readable script name.
  string name = 2;

  // TypeScript source code.
  string code = 3;

  // Incremental version number (updated on each modification).
  int32 version = 4;

  // Target agent IDs or service names (empty = all agents).
  repeated string targets = 5;

  // Script trigger configuration.
  ScriptTrigger trigger = 6;

  // Creation timestamp.
  google.protobuf.Timestamp created_at = 7;

  // Creator identifier (user ID or "ai").
  string created_by = 8;

  // Script description (optional).
  string description = 9;

  // Execution scope (global or service-scoped).
  ExecutionScope scope = 10;

  // Script type (adhoc or daemon) for timeout selection.
  ScriptType type = 11;

  // Service name (required if scope = EXECUTION_SCOPE_SERVICE).
  // When set, service context is dependency-injected into the script.
  string service_name = 12;

  // Script parameters (key-value pairs injected as environment variables).
  map<string, string> parameters = 13;

  // Community metadata (for script marketplace).
  string author = 14;
  repeated string tags = 15;
}

// ExecutionScope defines where a script can access data from.
enum ExecutionScope {
  EXECUTION_SCOPE_UNSPECIFIED = 0;

  // Global scripts can access all services, must specify service names.
  // Use case: Cross-service correlation, system-wide monitoring.
  EXECUTION_SCOPE_GLOBAL = 1;

  // Service-scoped scripts are bound to a specific service.
  // Service context is dependency-injected, making scripts portable.
  // Use case: Reusable community scripts that work for any service.
  EXECUTION_SCOPE_SERVICE = 2;
}

// ScriptType defines the execution timeout model.
enum ScriptType {
  SCRIPT_TYPE_UNSPECIFIED = 0;

  // Adhoc scripts are short-lived diagnostic queries (default: 60s timeout).
  SCRIPT_TYPE_ADHOC = 1;

  // Daemon scripts are long-running monitors (max: 24h timeout).
  SCRIPT_TYPE_DAEMON = 2;
}

// ScriptTrigger defines how and when a script executes.
message ScriptTrigger {
  oneof trigger {
    ManualTrigger manual = 1;      // One-time execution on deployment
    ScheduleTrigger schedule = 2;  // Periodic execution via cron
    EventTrigger event = 3;        // Execution on data condition
  }
}

// ManualTrigger executes script once when deployed.
message ManualTrigger {
  // Empty - script runs once immediately.
}

// ScheduleTrigger executes script periodically.
message ScheduleTrigger {
  // Cron expression (e.g., "*/5 * * * *" for every 5 minutes).
  string cron = 1;
}

// EventTrigger executes script when a condition is met.
message EventTrigger {
  // SQL condition to check (e.g., "SELECT 1 FROM beyla_http_metrics WHERE error_rate > 0.01").
  string condition = 1;

  // How often to check the condition (in seconds).
  int32 check_interval_seconds = 2;
}

// DeployScript RPC messages.

message DeployScriptRequest {
  // Script to deploy.
  Script script = 1;
}

message DeployScriptResponse {
  // Unique script identifier.
  string script_id = 1;

  // Version number assigned to this deployment.
  int32 version = 2;

  // Agent IDs where the script was deployed.
  repeated string deployed_to = 3;

  // Error message if deployment failed partially.
  string error = 4;
}

// StopScript RPC messages.

message StopScriptRequest {
  // Script ID to stop.
  string script_id = 1;
}

message StopScriptResponse {
  // Success indicator.
  bool success = 1;

  // Error message if stopping failed.
  string error = 2;

  // Number of agents where script was stopped.
  int32 stopped_count = 3;
}

// GetScriptStatus RPC messages.

message GetScriptStatusRequest {
  // Script ID to query.
  string script_id = 1;

  // Maximum number of recent executions to include (default: 10).
  int32 max_executions = 2;
}

message GetScriptStatusResponse {
  // Script identifier.
  string script_id = 1;

  // Overall script status.
  ScriptStatus status = 2;

  // Recent executions across all agents.
  repeated ScriptExecution executions = 3;

  // Total number of executions (may exceed length of executions array).
  int32 total_executions = 4;
}

// ScriptStatus represents the overall state of a script.
enum ScriptStatus {
  SCRIPT_STATUS_UNSPECIFIED = 0;
  SCRIPT_STATUS_PENDING = 1;      // Deployed but not yet started
  SCRIPT_STATUS_RUNNING = 2;      // Currently executing
  SCRIPT_STATUS_STOPPED = 3;      // Manually stopped
  SCRIPT_STATUS_FAILED = 4;       // Execution failed
  SCRIPT_STATUS_COMPLETED = 5;    // One-time script finished successfully
}

// ScriptExecution represents a single execution of a script on an agent.
message ScriptExecution {
  // Unique execution identifier (UUID).
  string execution_id = 1;

  // Script identifier.
  string script_id = 2;

  // Agent identifier where script executed.
  string agent_id = 3;

  // Execution status.
  ScriptStatus status = 4;

  // Execution start timestamp.
  google.protobuf.Timestamp started_at = 5;

  // Execution completion timestamp (if finished).
  google.protobuf.Timestamp completed_at = 6;

  // Exit code (0 = success, non-zero = error).
  int32 exit_code = 7;

  // Captured standard output (limited to last N bytes).
  string stdout = 8;

  // Captured standard error (limited to last N bytes).
  string stderr = 9;

  // Custom events emitted via sdk.emit().
  repeated ScriptEvent events = 10;

  // Error message if execution failed.
  string error = 11;
}

// ScriptEvent represents a custom event emitted by a script.
message ScriptEvent {
  // Event type (e.g., "alert", "metric", "log", "correlation").
  string name = 1;

  // Event payload as JSON string.
  string data = 2;

  // Event timestamp.
  google.protobuf.Timestamp timestamp = 3;

  // Event severity (optional: "info", "warning", "error", "critical").
  string severity = 4;
}

// StreamScriptLogs RPC messages.

message StreamScriptLogsRequest {
  // Script ID to stream logs from.
  string script_id = 1;

  // If true, stream logs in real-time (don't close stream).
  bool follow = 2;

  // Only show logs from specific agent (empty = all agents).
  string agent_id = 3;

  // Number of historical log lines to include before streaming (default: 100).
  int32 tail_lines = 4;
}

message ScriptLogEntry {
  // Log timestamp.
  google.protobuf.Timestamp timestamp = 1;

  // Log stream ("stdout" or "stderr").
  string stream = 2;

  // Log line content.
  string line = 3;

  // Agent ID where log originated.
  string agent_id = 4;

  // Execution ID for this log entry.
  string execution_id = 5;
}

// ListScripts RPC messages.

message ListScriptsRequest {
  // Filter by script status (empty = all statuses).
  repeated ScriptStatus status_filter = 1;

  // Filter by agent ID (empty = all agents).
  string agent_id = 2;

  // Maximum number of scripts to return (default: 100).
  int32 limit = 3;

  // Offset for pagination (default: 0).
  int32 offset = 4;
}

message ListScriptsResponse {
  // List of scripts matching the filter.
  repeated ScriptInfo scripts = 1;

  // Total number of scripts (may exceed length of scripts array).
  int32 total_scripts = 2;
}

message ScriptInfo {
  // Script metadata.
  Script script = 1;

  // Current overall status.
  ScriptStatus status = 2;

  // Number of active executions.
  int32 active_executions = 3;

  // Number of agents where script is deployed.
  int32 deployed_count = 4;

  // Last execution timestamp.
  google.protobuf.Timestamp last_execution = 5;
}

// DeleteScript RPC messages.

message DeleteScriptRequest {
  // Script ID to delete.
  string script_id = 1;

  // If true, stop all running executions before deleting.
  bool force = 2;
}

message DeleteScriptResponse {
  // Success indicator.
  bool success = 1;

  // Error message if deletion failed.
  string error = 2;
}
