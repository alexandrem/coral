package mcp

import (
	"context"
	"fmt"
	"time"

	"github.com/firebase/genkit/go/genkit"
)

// registerServiceHealthTool registers the coral_get_service_health tool.
func (s *Server) registerServiceHealthTool() {
	if !s.isToolEnabled("coral_get_service_health") {
		return
	}

	// Define tool using Genkit.
	genkit.DefineTool(
		s.genkit,
		"coral_get_service_health",
		"Get current health status of services. Returns health state, resource usage (CPU, memory), uptime, and recent issues.",
		func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
			s.auditToolCall("coral_get_service_health", args)

		// Extract service filter if provided.
		var serviceFilter string
		if filter, ok := args["service_filter"].(string); ok {
			serviceFilter = filter
		}

		// Get all agents from registry.
		agents := s.registry.ListAll()

		// Build health report.
		var healthyCount, degradedCount, unhealthyCount int
		var serviceStatuses []map[string]interface{}

		for _, agent := range agents {
			// Apply filter if specified.
			if serviceFilter != "" && !matchesPattern(agent.ComponentName, serviceFilter) {
				continue
			}

			// Determine health status based on last seen.
			status := "healthy"
			lastSeen := agent.LastSeen
			timeSinceLastSeen := time.Since(lastSeen)

			if timeSinceLastSeen > 5*time.Minute {
				status = "unhealthy"
				unhealthyCount++
			} else if timeSinceLastSeen > 2*time.Minute {
				status = "degraded"
				degradedCount++
			} else {
				healthyCount++
			}

			serviceStatuses = append(serviceStatuses, map[string]interface{}{
				"service":   agent.ComponentName,
				"agent_id":  agent.AgentID,
				"status":    status,
				"last_seen": lastSeen.Format(time.RFC3339),
				"uptime":    formatDuration(time.Since(agent.RegisteredAt)),
				"mesh_ip":   agent.MeshIPv4,
			})
		}

		// Determine overall status.
		overallStatus := "healthy"
		if unhealthyCount > 0 {
			overallStatus = "unhealthy"
		} else if degradedCount > 0 {
			overallStatus = "degraded"
		}

		// Format response as text for LLM consumption.
		text := fmt.Sprintf("System Health Report:\n\n")
		text += fmt.Sprintf("Overall Status: %s\n\n", overallStatus)
		text += fmt.Sprintf("Services:\n")

		if len(serviceStatuses) == 0 {
			text += "  No services connected.\n"
		} else {
			for _, svc := range serviceStatuses {
				statusEmoji := "✓"
				if svc["status"] == "degraded" {
					statusEmoji = "⚠"
				} else if svc["status"] == "unhealthy" {
					statusEmoji = "✗"
				}

				text += fmt.Sprintf("  %s %s: %s (last seen: %s, uptime: %s)\n",
					statusEmoji,
					svc["service"],
					svc["status"],
					svc["last_seen"],
					svc["uptime"],
				)
			}
		}

		text += fmt.Sprintf("\nSummary: %d healthy, %d degraded, %d unhealthy\n",
			healthyCount, degradedCount, unhealthyCount)

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// registerServiceTopologyTool registers the coral_get_service_topology tool.
func (s *Server) registerServiceTopologyTool() {
	if !s.isToolEnabled("coral_get_service_topology") {
		return
	}

	toolDef := map[string]interface{}{
		"name":        "coral_get_service_topology",
		"description": "Get service dependency graph discovered from distributed traces. Shows which services communicate and call frequency.",
		"inputSchema": map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"filter": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by service name, tag, or region",
				},
				"format": map[string]interface{}{
					"type":        "string",
					"description": "Output format",
					"enum":        []string{"graph", "list", "json"},
					"default":     "graph",
				},
			},
		},
	}

	s.mcpServer.RegisterTool("coral_get_service_topology", toolDef, func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		s.auditToolCall("coral_get_service_topology", args)

		// TODO: Implement topology discovery from traces (RFD 036).
		// For now, return connected agents as a simple topology.

		agents := s.registry.ListAgents()

		text := fmt.Sprintf("Service Topology:\n\n")
		text += fmt.Sprintf("Connected Services (%d):\n", len(agents))

		for _, agent := range agents {
			text += fmt.Sprintf("  - %s (mesh IP: %s)\n", agent.ComponentName, agent.MeshIPv4)
		}

		text += "\n"
		text += "Note: Dependency graph discovery from distributed traces is not yet implemented.\n"
		text += "      See RFD 036 for planned trace-based topology analysis.\n"

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// registerQueryEventsTool registers the coral_query_events tool.
func (s *Server) registerQueryEventsTool() {
	if !s.isToolEnabled("coral_query_events") {
		return
	}

	toolDef := map[string]interface{}{
		"name":        "coral_query_events",
		"description": "Query operational events tracked by Coral (deployments, restarts, crashes, alerts, configuration changes).",
		"inputSchema": map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"event_type": map[string]interface{}{
					"type":        "string",
					"description": "Event type filter",
					"enum":        []string{"deploy", "restart", "crash", "alert", "config_change", "connection", "error_spike"},
				},
				"time_range": map[string]interface{}{
					"type":        "string",
					"description": "Time range to search",
					"default":     "24h",
				},
				"service": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by service",
				},
			},
		},
	}

	s.mcpServer.RegisterTool("coral_query_events", toolDef, func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		s.auditToolCall("coral_query_events", args)

		// TODO: Implement event storage and querying.
		// For now, return placeholder.

		text := "Operational Events:\n\n"
		text += "No events tracked yet.\n\n"
		text += "Note: Event storage and querying is planned for future implementation.\n"
		text += "      Events will include deployments, restarts, crashes, and configuration changes.\n"

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// registerBeylaHTTPMetricsTool registers the coral_query_beyla_http_metrics tool.
func (s *Server) registerBeylaHTTPMetricsTool() {
	if !s.isToolEnabled("coral_query_beyla_http_metrics") {
		return
	}

	toolDef := map[string]interface{}{
		"name":        "coral_query_beyla_http_metrics",
		"description": "Query HTTP RED metrics collected by Beyla (request rate, error rate, latency distributions). Returns percentiles, status code breakdown, and route-level metrics.",
		"inputSchema": map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"service": map[string]interface{}{
					"type":        "string",
					"description": "Service name (required)",
				},
				"time_range": map[string]interface{}{
					"type":        "string",
					"description": "Time range (e.g., '1h', '30m', '24h')",
					"default":     "1h",
				},
				"http_route": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by HTTP route pattern (e.g., '/api/v1/users/:id')",
				},
				"http_method": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by HTTP method",
					"enum":        []string{"GET", "POST", "PUT", "DELETE", "PATCH"},
				},
				"status_code_range": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by status code range",
					"enum":        []string{"2xx", "3xx", "4xx", "5xx"},
				},
			},
			"required": []string{"service"},
		},
	}

	s.mcpServer.RegisterTool("coral_query_beyla_http_metrics", toolDef, func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		s.auditToolCall("coral_query_beyla_http_metrics", args)

		service, ok := args["service"].(string)
		if !ok || service == "" {
			return nil, fmt.Errorf("service parameter is required")
		}

		// Parse time range.
		timeRange := "1h"
		if tr, ok := args["time_range"].(string); ok {
			timeRange = tr
		}

		// TODO: Query Beyla HTTP metrics from database (RFD 032).
		// For now, return placeholder.

		text := fmt.Sprintf("Beyla HTTP Metrics for %s (last %s):\n\n", service, timeRange)
		text += "No metrics available yet.\n\n"
		text += "Note: Beyla HTTP RED metrics collection is implemented but requires agents to run Beyla.\n"
		text += "      See RFD 032 for Beyla integration details.\n"

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// registerBeylaGRPCMetricsTool registers the coral_query_beyla_grpc_metrics tool.
func (s *Server) registerBeylaGRPCMetricsTool() {
	if !s.isToolEnabled("coral_query_beyla_grpc_metrics") {
		return
	}

	toolDef := map[string]interface{}{
		"name":        "coral_query_beyla_grpc_metrics",
		"description": "Query gRPC method-level RED metrics collected by Beyla. Returns RPC rate, latency distributions, and status code breakdown.",
		"inputSchema": map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"service": map[string]interface{}{
					"type":        "string",
					"description": "Service name (required)",
				},
				"time_range": map[string]interface{}{
					"type":        "string",
					"description": "Time range (e.g., '1h', '30m', '24h')",
					"default":     "1h",
				},
				"grpc_method": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by gRPC method (e.g., '/payments.PaymentService/Charge')",
				},
				"status_code": map[string]interface{}{
					"type":        "integer",
					"description": "Optional: Filter by gRPC status code (0=OK, 1=CANCELLED, etc.)",
				},
			},
			"required": []string{"service"},
		},
	}

	s.mcpServer.RegisterTool("coral_query_beyla_grpc_metrics", toolDef, func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		s.auditToolCall("coral_query_beyla_grpc_metrics", args)

		service, ok := args["service"].(string)
		if !ok || service == "" {
			return nil, fmt.Errorf("service parameter is required")
		}

		timeRange := "1h"
		if tr, ok := args["time_range"].(string); ok {
			timeRange = tr
		}

		text := fmt.Sprintf("Beyla gRPC Metrics for %s (last %s):\n\n", service, timeRange)
		text += "No metrics available yet.\n\n"
		text += "Note: Beyla gRPC metrics collection is planned (RFD 032).\n"

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// registerBeylaSQLMetricsTool registers the coral_query_beyla_sql_metrics tool.
func (s *Server) registerBeylaSQLMetricsTool() {
	if !s.isToolEnabled("coral_query_beyla_sql_metrics") {
		return
	}

	toolDef := map[string]interface{}{
		"name":        "coral_query_beyla_sql_metrics",
		"description": "Query SQL operation metrics collected by Beyla. Returns query latencies, operation types, and table-level statistics.",
		"inputSchema": map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"service": map[string]interface{}{
					"type":        "string",
					"description": "Service name (required)",
				},
				"time_range": map[string]interface{}{
					"type":        "string",
					"description": "Time range (e.g., '1h', '30m', '24h')",
					"default":     "1h",
				},
				"sql_operation": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by SQL operation",
					"enum":        []string{"SELECT", "INSERT", "UPDATE", "DELETE"},
				},
				"table_name": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by table name",
				},
			},
			"required": []string{"service"},
		},
	}

	s.mcpServer.RegisterTool("coral_query_beyla_sql_metrics", toolDef, func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		s.auditToolCall("coral_query_beyla_sql_metrics", args)

		service, ok := args["service"].(string)
		if !ok || service == "" {
			return nil, fmt.Errorf("service parameter is required")
		}

		timeRange := "1h"
		if tr, ok := args["time_range"].(string); ok {
			timeRange = tr
		}

		text := fmt.Sprintf("Beyla SQL Metrics for %s (last %s):\n\n", service, timeRange)
		text += "No metrics available yet.\n\n"
		text += "Note: Beyla SQL metrics collection is planned (RFD 032).\n"

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// registerBeylaTracesTool registers the coral_query_beyla_traces tool.
func (s *Server) registerBeylaTracesTool() {
	if !s.isToolEnabled("coral_query_beyla_traces") {
		return
	}

	toolDef := map[string]interface{}{
		"name":        "coral_query_beyla_traces",
		"description": "Query distributed traces collected by Beyla. Can search by trace ID, service, time range, or duration threshold.",
		"inputSchema": map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"trace_id": map[string]interface{}{
					"type":        "string",
					"description": "Specific trace ID (32-char hex string)",
				},
				"service": map[string]interface{}{
					"type":        "string",
					"description": "Filter traces involving this service",
				},
				"time_range": map[string]interface{}{
					"type":        "string",
					"description": "Time range (e.g., '1h', '30m', '24h')",
					"default":     "1h",
				},
				"min_duration_ms": map[string]interface{}{
					"type":        "integer",
					"description": "Optional: Only return traces longer than this duration (milliseconds)",
				},
				"max_traces": map[string]interface{}{
					"type":        "integer",
					"description": "Maximum number of traces to return",
					"default":     10,
				},
			},
		},
	}

	s.mcpServer.RegisterTool("coral_query_beyla_traces", toolDef, func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		s.auditToolCall("coral_query_beyla_traces", args)

		text := "Beyla Distributed Traces:\n\n"
		text += "No traces available yet.\n\n"
		text += "Note: Beyla distributed tracing is planned (RFD 036).\n"

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// registerTraceByIDTool registers the coral_get_trace_by_id tool.
func (s *Server) registerTraceByIDTool() {
	if !s.isToolEnabled("coral_get_trace_by_id") {
		return
	}

	toolDef := map[string]interface{}{
		"name":        "coral_get_trace_by_id",
		"description": "Get a specific distributed trace by ID with full span tree showing parent-child relationships and timing.",
		"inputSchema": map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"trace_id": map[string]interface{}{
					"type":        "string",
					"description": "Trace ID (32-char hex string)",
				},
				"format": map[string]interface{}{
					"type":        "string",
					"description": "Output format",
					"enum":        []string{"tree", "flat", "json"},
					"default":     "tree",
				},
			},
			"required": []string{"trace_id"},
		},
	}

	s.mcpServer.RegisterTool("coral_get_trace_by_id", toolDef, func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		s.auditToolCall("coral_get_trace_by_id", args)

		traceID, ok := args["trace_id"].(string)
		if !ok || traceID == "" {
			return nil, fmt.Errorf("trace_id parameter is required")
		}

		text := fmt.Sprintf("Trace %s:\n\n", traceID)
		text += "Trace not found.\n\n"
		text += "Note: Trace retrieval is planned (RFD 036).\n"

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// registerTelemetrySpansTool registers the coral_query_telemetry_spans tool.
func (s *Server) registerTelemetrySpansTool() {
	if !s.isToolEnabled("coral_query_telemetry_spans") {
		return
	}

	toolDef := map[string]interface{}{
		"name":        "coral_query_telemetry_spans",
		"description": "Query generic OTLP spans (from instrumented applications using OpenTelemetry SDKs). Complementary to Beyla traces.",
		"inputSchema": map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"service": map[string]interface{}{
					"type":        "string",
					"description": "Service name",
				},
				"time_range": map[string]interface{}{
					"type":        "string",
					"description": "Time range (e.g., '1h', '30m', '24h')",
					"default":     "1h",
				},
				"operation": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by operation name",
				},
			},
			"required": []string{"service"},
		},
	}

	s.mcpServer.RegisterTool("coral_query_telemetry_spans", toolDef, func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		s.auditToolCall("coral_query_telemetry_spans", args)

		text := "OTLP Spans:\n\n"
		text += "No spans available yet.\n\n"
		text += "Note: OTLP span querying is implemented (RFD 025) but requires telemetry data.\n"

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// registerTelemetryMetricsTool registers the coral_query_telemetry_metrics tool.
func (s *Server) registerTelemetryMetricsTool() {
	if !s.isToolEnabled("coral_query_telemetry_metrics") {
		return
	}

	toolDef := map[string]interface{}{
		"name":        "coral_query_telemetry_metrics",
		"description": "Query generic OTLP metrics (from instrumented applications). Returns time-series data for custom application metrics.",
		"inputSchema": map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"metric_name": map[string]interface{}{
					"type":        "string",
					"description": "Metric name (e.g., 'http.server.duration', 'custom.orders.count')",
				},
				"service": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by service",
				},
				"time_range": map[string]interface{}{
					"type":        "string",
					"description": "Time range",
					"default":     "1h",
				},
			},
		},
	}

	s.mcpServer.RegisterTool("coral_query_telemetry_metrics", toolDef, func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		s.auditToolCall("coral_query_telemetry_metrics", args)

		text := "OTLP Metrics:\n\n"
		text += "No metrics available yet.\n\n"
		text += "Note: OTLP metrics querying is implemented (RFD 025) but requires telemetry data.\n"

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// registerTelemetryLogsTool registers the coral_query_telemetry_logs tool.
func (s *Server) registerTelemetryLogsTool() {
	if !s.isToolEnabled("coral_query_telemetry_logs") {
		return
	}

	toolDef := map[string]interface{}{
		"name":        "coral_query_telemetry_logs",
		"description": "Query generic OTLP logs (from instrumented applications). Search application logs with full-text search and filters.",
		"inputSchema": map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"query": map[string]interface{}{
					"type":        "string",
					"description": "Search query (full-text search)",
				},
				"service": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by service",
				},
				"level": map[string]interface{}{
					"type":        "string",
					"description": "Optional: Filter by log level",
					"enum":        []string{"DEBUG", "INFO", "WARN", "ERROR", "FATAL"},
				},
				"time_range": map[string]interface{}{
					"type":        "string",
					"description": "Time range",
					"default":     "1h",
				},
			},
		},
	}

	s.mcpServer.RegisterTool("coral_query_telemetry_logs", toolDef, func(ctx context.Context, args map[string]interface{}) (interface{}, error) {
		s.auditToolCall("coral_query_telemetry_logs", args)

		text := "OTLP Logs:\n\n"
		text += "No logs available yet.\n\n"
		text += "Note: OTLP log querying is implemented (RFD 025) but requires telemetry data.\n"

		return map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": text,
				},
			},
		}, nil
	})
}

// matchesPattern checks if a string matches a simple glob pattern.
// Supports '*' as wildcard only.
func matchesPattern(s, pattern string) bool {
	if pattern == "" {
		return true
	}
	// Simple wildcard matching - just check if pattern is a prefix/suffix.
	if pattern == "*" {
		return true
	}
	if len(pattern) > 0 && pattern[len(pattern)-1] == '*' {
		prefix := pattern[:len(pattern)-1]
		return len(s) >= len(prefix) && s[:len(prefix)] == prefix
	}
	if len(pattern) > 0 && pattern[0] == '*' {
		suffix := pattern[1:]
		return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
	}
	return s == pattern
}

// formatDuration formats a duration in human-readable form.
func formatDuration(d time.Duration) string {
	if d < time.Minute {
		return fmt.Sprintf("%ds", int(d.Seconds()))
	}
	if d < time.Hour {
		return fmt.Sprintf("%dm", int(d.Minutes()))
	}
	if d < 24*time.Hour {
		return fmt.Sprintf("%dh", int(d.Hours()))
	}
	days := int(d.Hours() / 24)
	return fmt.Sprintf("%dd", days)
}
